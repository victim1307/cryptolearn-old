<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <link rel="canonical" href="https://victim1307.github.io/cryptolearn/print-version/">
    <link rel="apple-touch-icon" sizes="57x57" href="https://victim1307.github.io/cryptolearn/images/apple-touch-icon-57x57.png">
    <link rel="apple-touch-icon" sizes="60x60" href="https://victim1307.github.io/cryptolearn/images/apple-touch-icon-60x60.png">
    <link rel="apple-touch-icon" sizes="72x72" href="https://victim1307.github.io/cryptolearn/images/apple-touch-icon-72x72.png">
    <link rel="apple-touch-icon" sizes="76x76" href="https://victim1307.github.io/cryptolearn/images/apple-touch-icon-76x76.png">
    <link rel="apple-touch-icon" sizes="114x114" href="https://victim1307.github.io/cryptolearn/images/apple-touch-icon-114x114.png">
    <link rel="apple-touch-icon" sizes="120x120" href="https://victim1307.github.io/cryptolearn/images/apple-touch-icon-120x120.png">
    <link rel="apple-touch-icon" sizes="144x144" href="https://victim1307.github.io/cryptolearn/images/apple-touch-icon-144x144.png">
    <link rel="apple-touch-icon" sizes="152x152" href="https://victim1307.github.io/cryptolearn/images/apple-touch-icon-152x152.png">
    <link rel="apple-touch-icon" sizes="180x180" href="https://victim1307.github.io/cryptolearn/images/apple-touch-icon-180x180.png">
    <link rel="icon" type="image/png" sizes="192x192"  href="https://victim1307.github.io/cryptolearn/images/android-icon-192x192.png">
    <link rel="icon" type="image/png" sizes="32x32" href="https://victim1307.github.io/cryptolearn/images/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="96x96" href="https://victim1307.github.io/cryptolearn/images/favicon-96x96.png">
    <link rel="icon" type="image/png" sizes="16x16" href="https://victim1307.github.io/cryptolearn/images/favicon-16x16.png">
    <meta name="msapplication-TileColor" content="#ffffff">
    <meta name="msapplication-TileImage" content="https://victim1307.github.io/cryptolearn/images/ms-icon-144x144.png">
    <meta name="theme-color" content="#ffffff">
    <link rel="stylesheet" href="https://victim1307.github.io/cryptolearn/css/prism.css" media="none" onload="this.media='all';">
    <link rel="stylesheet" type="text/css" href="https://victim1307.github.io/cryptolearn/css/styles.css">
    <style id="inverter" media="none">
      html { filter: invert(100%) }
      * { background-color: inherit }
      img:not([src*=".svg"]), .colors, iframe, .demo-container { filter: invert(100%) }
    </style>
    <title>
      
  CryptoLearn

    </title>
    
  </head>
  <body>
    
    <svg style="display: none">
  <symbol id="bookmark" viewBox="0 0 40 50">
   <g transform="translate(2266 3206.2)">
    <path style="stroke:currentColor;stroke-width:3.2637;fill:none" d="m-2262.2-3203.4-.2331 42.195 16.319-16.318 16.318 16.318.2331-42.428z"/>
   </g>
  </symbol>

  <symbol id="w3c" viewBox="0 0 127.09899 67.763">
   <text font-size="83" style="font-size:83px;font-family:Trebuchet;letter-spacing:-12;fill-opacity:0" letter-spacing="-12" y="67.609352" x="-26.782778">W3C</text>
   <text font-size="83" style="font-size:83px;font-weight:bold;font-family:Trebuchet;fill-opacity:0" y="67.609352" x="153.21722" font-weight="bold">SVG</text>
   <path style="fill:currentColor;image-rendering:optimizeQuality;shape-rendering:geometricPrecision" d="m33.695.377 12.062 41.016 12.067-41.016h8.731l-19.968 67.386h-.831l-12.48-41.759-12.479 41.759h-.832l-19.965-67.386h8.736l12.061 41.016 8.154-27.618-3.993-13.397h8.737z"/>
   <path style="fill:currentColor;image-rendering:optimizeQuality;shape-rendering:geometricPrecision" d="m91.355 46.132c0 6.104-1.624 11.234-4.862 15.394-3.248 4.158-7.45 6.237-12.607 6.237-3.882 0-7.263-1.238-10.148-3.702-2.885-2.47-5.02-5.812-6.406-10.022l6.82-2.829c1.001 2.552 2.317 4.562 3.953 6.028 1.636 1.469 3.56 2.207 5.781 2.207 2.329 0 4.3-1.306 5.909-3.911 1.609-2.606 2.411-5.738 2.411-9.401 0-4.049-.861-7.179-2.582-9.399-1.995-2.604-5.129-3.912-9.397-3.912h-3.327v-3.991l11.646-20.133h-14.062l-3.911 6.655h-2.493v-14.976h32.441v4.075l-12.31 21.217c4.324 1.385 7.596 3.911 9.815 7.571 2.22 3.659 3.329 7.953 3.329 12.892z"/>
   <path style="fill:currentColor;image-rendering:optimizeQuality;shape-rendering:geometricPrecision" d="m125.21 0 1.414 8.6-5.008 9.583s-1.924-4.064-5.117-6.314c-2.693-1.899-4.447-2.309-7.186-1.746-3.527.73-7.516 4.938-9.258 10.13-2.084 6.21-2.104 9.218-2.178 11.978-.115 4.428.58 7.043.58 7.043s-3.04-5.626-3.011-13.866c.018-5.882.947-11.218 3.666-16.479 2.404-4.627 5.954-7.404 9.114-7.728 3.264-.343 5.848 1.229 7.841 2.938 2.089 1.788 4.213 5.698 4.213 5.698l4.94-9.837z"/>
   <path style="fill:currentColor;image-rendering:optimizeQuality;shape-rendering:geometricPrecision" d="m125.82 48.674s-2.208 3.957-3.589 5.48c-1.379 1.524-3.849 4.209-6.896 5.555-3.049 1.343-4.646 1.598-7.661 1.306-3.01-.29-5.807-2.032-6.786-2.764-.979-.722-3.486-2.864-4.897-4.854-1.42-2-3.634-5.995-3.634-5.995s1.233 4.001 2.007 5.699c.442.977 1.81 3.965 3.749 6.572 1.805 2.425 5.315 6.604 10.652 7.545 5.336.945 9.002-1.449 9.907-2.031.907-.578 2.819-2.178 4.032-3.475 1.264-1.351 2.459-3.079 3.116-4.108.487-.758 1.276-2.286 1.276-2.286l-1.276-6.644z"/>
  </symbol>

  <symbol id="tag" viewBox="0 0 177.16535 177.16535">
    <g transform="translate(0 -875.2)">
     <path style="fill-rule:evenodd;stroke-width:0;fill:currentColor" d="m159.9 894.3-68.79 8.5872-75.42 77.336 61.931 60.397 75.429-76.565 6.8495-69.755zm-31.412 31.835a10.813 10.813 0 0 1 1.8443 2.247 10.813 10.813 0 0 1 -3.5174 14.872l-.0445.0275a10.813 10.813 0 0 1 -14.86 -3.5714 10.813 10.813 0 0 1 3.5563 -14.863 10.813 10.813 0 0 1 13.022 1.2884z"/>
    </g>
  </symbol>

  <symbol id="balloon" viewBox="0 0 141.73228 177.16535">
   <g transform="translate(0 -875.2)">
    <g>
     <path style="fill:currentColor" d="m68.156 882.83-.88753 1.4269c-4.9564 7.9666-6.3764 17.321-5.6731 37.378.36584 10.437 1.1246 23.51 1.6874 29.062.38895 3.8372 3.8278 32.454 4.6105 38.459 4.6694-.24176 9.2946.2879 14.377 1.481 1.2359-3.2937 5.2496-13.088 8.886-21.623 6.249-14.668 8.4128-21.264 10.253-31.252 1.2464-6.7626 1.6341-12.156 1.4204-19.764-.36325-12.93-2.1234-19.487-6.9377-25.843-2.0833-2.7507-6.9865-7.6112-7.9127-7.8436-.79716-.20019-6.6946-1.0922-6.7755-1.0248-.02213.0182-5.0006-.41858-7.5248-.22808l-2.149-.22808h-3.3738z"/>
     <path style="fill:currentColor" d="m61.915 883.28-3.2484.4497c-1.7863.24724-3.5182.53481-3.8494.63994-2.4751.33811-4.7267.86957-6.7777 1.5696-.28598 0-1.0254.20146-2.3695.58589-5.0418 1.4418-6.6374 2.2604-8.2567 4.2364-6.281 7.6657-11.457 18.43-12.932 26.891-1.4667 8.4111.71353 22.583 5.0764 32.996 3.8064 9.0852 13.569 25.149 22.801 37.517 1.3741 1.841 2.1708 2.9286 2.4712 3.5792 3.5437-1.1699 6.8496-1.9336 10.082-2.3263-1.3569-5.7831-4.6968-21.86-6.8361-33.002-.92884-4.8368-2.4692-14.322-3.2452-19.991-.68557-5.0083-.77707-6.9534-.74159-15.791.04316-10.803.41822-16.162 1.5026-21.503 1.4593-5.9026 3.3494-11.077 6.3247-15.852z"/>
     <path style="fill:currentColor" d="m94.499 885.78c-.10214-.0109-.13691 0-.0907.0409.16033.13489 1.329 1.0675 2.5976 2.0723 6.7003 5.307 11.273 14.568 12.658 25.638.52519 4.1949.24765 14.361-.5059 18.523-2.4775 13.684-9.7807 32.345-20.944 53.519l-3.0559 5.7971c2.8082.76579 5.7915 1.727 8.9926 2.8441 11.562-11.691 18.349-19.678 24.129-28.394 7.8992-11.913 11.132-20.234 12.24-31.518.98442-10.02-1.5579-20.876-6.7799-28.959-.2758-.4269-.57803-.86856-.89617-1.3166-3.247-6.13-9.752-12.053-21.264-16.131-2.3687-.86369-6.3657-2.0433-7.0802-2.1166z"/>
     <path style="fill:currentColor" d="m32.52 892.22c-.20090-.13016-1.4606.81389-3.9132 2.7457-11.486 9.0476-17.632 24.186-16.078 39.61.79699 7.9138 2.4066 13.505 5.9184 20.562 5.8577 11.77 14.749 23.219 30.087 38.74.05838.059.12188.1244.18052.1838 1.3166-.5556 2.5965-1.0618 3.8429-1.5199-.66408-.32448-1.4608-1.3297-3.8116-4.4602-5.0951-6.785-8.7512-11.962-13.051-18.486-5.1379-7.7948-5.0097-7.5894-8.0586-13.054-6.2097-11.13-8.2674-17.725-8.6014-27.563-.21552-6.3494.13041-9.2733 1.775-14.987 2.1832-7.5849 3.9273-10.986 9.2693-18.07 1.7839-2.3656 2.6418-3.57 2.4409-3.7003z"/>
     <path style="fill:currentColor" d="m69.133 992.37c-6.2405.0309-12.635.76718-19.554 2.5706 4.6956 4.7759 9.935 10.258 12.05 12.625l4.1272 4.6202h11.493l3.964-4.4516c2.0962-2.3541 7.4804-7.9845 12.201-12.768-8.378-1.4975-16.207-2.6353-24.281-2.5955z"/>
     <rect style="stroke-width:0;fill:currentColor" ry="2.0328" height="27.746" width="22.766" y="1017.7" x="60.201"/>
    </g>
   </g>
  </symbol>

  <symbol id="info" viewBox="0 0 41.667 41.667">
   <g transform="translate(-37.035 -1004.6)">
    <path style="stroke-linejoin:round;stroke:currentColor;stroke-linecap:round;stroke-width:3.728;fill:none" d="m76.25 1030.2a18.968 18.968 0 0 1 -23.037 13.709 18.968 18.968 0 0 1 -13.738 -23.019 18.968 18.968 0 0 1 23.001 -13.768 18.968 18.968 0 0 1 13.798 22.984"/>
    <g transform="matrix(1.1146 0 0 1.1146 -26.276 -124.92)">
     <path style="stroke:currentColor;stroke-linecap:round;stroke-width:3.728;fill:none" d="m75.491 1039.5v-8.7472"/>
     <path style="stroke-width:0;fill:currentColor" transform="scale(-1)" d="m-73.193-1024.5a2.3719 2.3719 0 0 1 -2.8807 1.7142 2.3719 2.3719 0 0 1 -1.718 -2.8785 2.3719 2.3719 0 0 1 2.8763 -1.7217 2.3719 2.3719 0 0 1 1.7254 2.8741"/>
    </g>
   </g>
  </symbol>

  <symbol id="warning" viewBox="0 0 48.430474 41.646302">
    <g transform="translate(-1.1273 -1010.2)">
     <path style="stroke-linejoin:round;stroke:currentColor;stroke-linecap:round;stroke-width:4.151;fill:none" d="m25.343 1012.3-22.14 37.496h44.28z"/>
     <path style="stroke:currentColor;stroke-linecap:round;stroke-width:4.1512;fill:none" d="m25.54 1027.7v8.7472"/>
     <path style="stroke-width:0;fill:currentColor" d="m27.839 1042.8a2.3719 2.3719 0 0 1 -2.8807 1.7143 2.3719 2.3719 0 0 1 -1.718 -2.8785 2.3719 2.3719 0 0 1 2.8763 -1.7217 2.3719 2.3719 0 0 1 1.7254 2.8741"/>
    </g>
  </symbol>

  <symbol id="menu" viewBox="0 0 50 50">
     <rect style="stroke-width:0;fill:currentColor" height="10" width="50" y="0" x="0"/>
     <rect style="stroke-width:0;fill:currentColor" height="10" width="50" y="20" x="0"/>
     <rect style="stroke-width:0;fill:currentColor" height="10" width="50" y="40" x="0"/>
   </symbol>

   <symbol id="link" viewBox="0 0 50 50">
    <g transform="translate(0 -1002.4)">
     <g transform="matrix(.095670 0 0 .095670 2.3233 1004.9)">
      <g>
       <path style="stroke-width:0;fill:currentColor" d="m452.84 192.9-128.65 128.65c-35.535 35.54-93.108 35.54-128.65 0l-42.881-42.886 42.881-42.876 42.884 42.876c11.845 11.822 31.064 11.846 42.886 0l128.64-128.64c11.816-11.831 11.816-31.066 0-42.9l-42.881-42.881c-11.822-11.814-31.064-11.814-42.887 0l-45.928 45.936c-21.292-12.531-45.491-17.905-69.449-16.291l72.501-72.526c35.535-35.521 93.136-35.521 128.64 0l42.886 42.881c35.535 35.523 35.535 93.141-.001 128.66zm-254.28 168.51-45.903 45.9c-11.845 11.846-31.064 11.817-42.881 0l-42.884-42.881c-11.845-11.821-11.845-31.041 0-42.886l128.65-128.65c11.819-11.814 31.069-11.814 42.884 0l42.886 42.886 42.876-42.886-42.876-42.881c-35.54-35.521-93.113-35.521-128.65 0l-128.65 128.64c-35.538 35.545-35.538 93.146 0 128.65l42.883 42.882c35.51 35.54 93.11 35.54 128.65 0l72.496-72.499c-23.956 1.597-48.092-3.784-69.474-16.283z"/>
      </g>
     </g>
    </g>
  </symbol>

  <symbol id="doc" viewBox="0 0 35 45">
   <g transform="translate(-147.53 -539.83)">
    <path style="stroke:currentColor;stroke-width:2.4501;fill:none" d="m149.38 542.67v39.194h31.354v-39.194z"/>
    <g style="stroke-width:25" transform="matrix(.098003 0 0 .098003 133.69 525.96)">
     <path d="m220 252.36h200" style="stroke:currentColor;stroke-width:25;fill:none"/>
     <path style="stroke:currentColor;stroke-width:25;fill:none" d="m220 409.95h200"/>
     <path d="m220 488.74h200" style="stroke:currentColor;stroke-width:25;fill:none"/>
     <path d="m220 331.15h200" style="stroke:currentColor;stroke-width:25;fill:none"/>
    </g>
   </g>
 </symbol>

 <symbol id="tick" viewBox="0 0 177.16535 177.16535">
  <g transform="translate(0 -875.2)">
   <rect style="stroke-width:0;fill:currentColor" transform="rotate(30)" height="155" width="40" y="702.99" x="556.82"/>
   <rect style="stroke-width:0;fill:currentColor" transform="rotate(30)" height="40" width="90.404" y="817.99" x="506.42"/>
  </g>
 </symbol>
</svg>

    <div class="wrapper print-version">
        <header class="intro-and-nav" role="banner">
          <div>
            <div class="intro">
              <a class="logo" href="https://victim1307.github.io/cryptolearn/" aria-label="CryptoLearn home page">
                <img src="https://victim1307.github.io/cryptolearn/images/logo.svg" alt="">
              </a>
              <p class="library-desc">
                A place to learn about cryptography from 0
                
               </a>
              </p>
              
                <p class="toc-link">
                  <span aria-hidden="true">&#x2193;</span>
                  <a href="#toc">Table of contents</a>
                  <span aria-hidden="true">&#x2193;</span>
                </p>
              
            </div>
            


          </div>
        </header>
      <div class="main-and-footer">
        <div>
          
  <main id="main">
    <nav id="toc" class="toc patterns" aria-labelledby="toc-heading">
      <h2 id="toc-heading">Table of contents</h2>
      
      
        <ul id="patterns-list">
          
            <li class="pattern">
              <a href="#1.-where-to-begin" >
                <svg class="bookmark-icon" aria-hidden="true" viewBox="0 0 40 50" focusable="false">
                  <use xlink:href="#bookmark"></use>
                </svg>
                <span class="text">1. Where to begin</span>
              </a>
            </li>
          
            <li class="pattern">
              <a href="#2.-basic-concepts" >
                <svg class="bookmark-icon" aria-hidden="true" viewBox="0 0 40 50" focusable="false">
                  <use xlink:href="#bookmark"></use>
                </svg>
                <span class="text">2. Basic Concepts</span>
              </a>
            </li>
          
            <li class="pattern">
              <a href="#3.-classic-cryptography" >
                <svg class="bookmark-icon" aria-hidden="true" viewBox="0 0 40 50" focusable="false">
                  <use xlink:href="#bookmark"></use>
                </svg>
                <span class="text">3. Classic Cryptography</span>
              </a>
            </li>
          
            <li class="pattern">
              <a href="#4.-stream-block-ciphers" >
                <svg class="bookmark-icon" aria-hidden="true" viewBox="0 0 40 50" focusable="false">
                  <use xlink:href="#bookmark"></use>
                </svg>
                <span class="text">4. Stream &amp; Block Ciphers</span>
              </a>
            </li>
          
            <li class="pattern">
              <a href="#5.-rsa" >
                <svg class="bookmark-icon" aria-hidden="true" viewBox="0 0 40 50" focusable="false">
                  <use xlink:href="#bookmark"></use>
                </svg>
                <span class="text">5. RSA</span>
              </a>
            </li>
          
            <li class="pattern">
              <a href="#6.-diffie-hellman" >
                <svg class="bookmark-icon" aria-hidden="true" viewBox="0 0 40 50" focusable="false">
                  <use xlink:href="#bookmark"></use>
                </svg>
                <span class="text">6. Diffie Hellman</span>
              </a>
            </li>
          
            <li class="pattern">
              <a href="#6.-elliptic-curve-cryptography" >
                <svg class="bookmark-icon" aria-hidden="true" viewBox="0 0 40 50" focusable="false">
                  <use xlink:href="#bookmark"></use>
                </svg>
                <span class="text">6. Elliptic Curve Cryptography</span>
              </a>
            </li>
          
          
            <li>
              <h3>2. Basic Concepts</h3>
              <ul>
                
                  <li class="pattern">
                    <a href="#hello-world" >
                      <svg class="bookmark-icon" aria-hidden="true" viewBox="0 0 40 50" focusable="false">
                        <use xlink:href="#bookmark"></use>
                      </svg>
                      <span class="text">hello world</span>
                    </a>
                  </li>
                
                  <li class="pattern">
                    <a href="#where-to-ghfghfcbegin" >
                      <svg class="bookmark-icon" aria-hidden="true" viewBox="0 0 40 50" focusable="false">
                        <use xlink:href="#bookmark"></use>
                      </svg>
                      <span class="text">Where to ghfghfcbegin</span>
                    </a>
                  </li>
                
                  <li class="pattern">
                    <a href="#hello-world-2" >
                      <svg class="bookmark-icon" aria-hidden="true" viewBox="0 0 40 50" focusable="false">
                        <use xlink:href="#bookmark"></use>
                      </svg>
                      <span class="text">hello world 2</span>
                    </a>
                  </li>
                
              </ul>
            </li>
          
            <li>
              <h3>3. Classic Cryptography</h3>
              <ul>
                
                  <li class="pattern">
                    <a href="#shift-cipher" >
                      <svg class="bookmark-icon" aria-hidden="true" viewBox="0 0 40 50" focusable="false">
                        <use xlink:href="#bookmark"></use>
                      </svg>
                      <span class="text">Shift Cipher</span>
                    </a>
                  </li>
                
                  <li class="pattern">
                    <a href="#affine-cipher" >
                      <svg class="bookmark-icon" aria-hidden="true" viewBox="0 0 40 50" focusable="false">
                        <use xlink:href="#bookmark"></use>
                      </svg>
                      <span class="text">Affine Cipher</span>
                    </a>
                  </li>
                
                  <li class="pattern">
                    <a href="#atbash-cipher" >
                      <svg class="bookmark-icon" aria-hidden="true" viewBox="0 0 40 50" focusable="false">
                        <use xlink:href="#bookmark"></use>
                      </svg>
                      <span class="text">Atbash Cipher</span>
                    </a>
                  </li>
                
                  <li class="pattern">
                    <a href="#playfair-cipher" >
                      <svg class="bookmark-icon" aria-hidden="true" viewBox="0 0 40 50" focusable="false">
                        <use xlink:href="#bookmark"></use>
                      </svg>
                      <span class="text">Playfair Cipher</span>
                    </a>
                  </li>
                
              </ul>
            </li>
          
            <li>
              <h3>4. Stream &amp; Block Ciphers</h3>
              <ul>
                
                  <li class="pattern">
                    <a href="#introduction" >
                      <svg class="bookmark-icon" aria-hidden="true" viewBox="0 0 40 50" focusable="false">
                        <use xlink:href="#bookmark"></use>
                      </svg>
                      <span class="text">Introduction</span>
                    </a>
                  </li>
                
                  <li class="pattern">
                    <a href="#single-byte-xor" >
                      <svg class="bookmark-icon" aria-hidden="true" viewBox="0 0 40 50" focusable="false">
                        <use xlink:href="#bookmark"></use>
                      </svg>
                      <span class="text">Single Byte XOR</span>
                    </a>
                  </li>
                
                  <li class="pattern">
                    <a href="#repeated-key-xor" >
                      <svg class="bookmark-icon" aria-hidden="true" viewBox="0 0 40 50" focusable="false">
                        <use xlink:href="#bookmark"></use>
                      </svg>
                      <span class="text">Repeated Key XOR</span>
                    </a>
                  </li>
                
                  <li class="pattern">
                    <a href="#transposition-ciphers" >
                      <svg class="bookmark-icon" aria-hidden="true" viewBox="0 0 40 50" focusable="false">
                        <use xlink:href="#bookmark"></use>
                      </svg>
                      <span class="text">Transposition ciphers</span>
                    </a>
                  </li>
                
                  <li class="pattern">
                    <a href="#modes-of-block-cipher" >
                      <svg class="bookmark-icon" aria-hidden="true" viewBox="0 0 40 50" focusable="false">
                        <use xlink:href="#bookmark"></use>
                      </svg>
                      <span class="text">Modes of block cipher</span>
                    </a>
                  </li>
                
              </ul>
            </li>
          
            <li>
              <h3>5. RSA</h3>
              <ul>
                
                  <li class="pattern">
                    <a href="#introduction" >
                      <svg class="bookmark-icon" aria-hidden="true" viewBox="0 0 40 50" focusable="false">
                        <use xlink:href="#bookmark"></use>
                      </svg>
                      <span class="text">Introduction</span>
                    </a>
                  </li>
                
                  <li class="pattern">
                    <a href="#common-modulus-attack" >
                      <svg class="bookmark-icon" aria-hidden="true" viewBox="0 0 40 50" focusable="false">
                        <use xlink:href="#bookmark"></use>
                      </svg>
                      <span class="text">Common Modulus Attack</span>
                    </a>
                  </li>
                
                  <li class="pattern">
                    <a href="#hastads-broadcast-attack" >
                      <svg class="bookmark-icon" aria-hidden="true" viewBox="0 0 40 50" focusable="false">
                        <use xlink:href="#bookmark"></use>
                      </svg>
                      <span class="text">Hastad&#39;s Broadcast Attack</span>
                    </a>
                  </li>
                
                  <li class="pattern">
                    <a href="#wiener-attack" >
                      <svg class="bookmark-icon" aria-hidden="true" viewBox="0 0 40 50" focusable="false">
                        <use xlink:href="#bookmark"></use>
                      </svg>
                      <span class="text">Wiener Attack</span>
                    </a>
                  </li>
                
                  <li class="pattern">
                    <a href="#factorisation" >
                      <svg class="bookmark-icon" aria-hidden="true" viewBox="0 0 40 50" focusable="false">
                        <use xlink:href="#bookmark"></use>
                      </svg>
                      <span class="text">Factorisation</span>
                    </a>
                  </li>
                
                  <li class="pattern">
                    <a href="#coppersmiths-method" >
                      <svg class="bookmark-icon" aria-hidden="true" viewBox="0 0 40 50" focusable="false">
                        <use xlink:href="#bookmark"></use>
                      </svg>
                      <span class="text">Coppersmith&#39;s Method</span>
                    </a>
                  </li>
                
              </ul>
            </li>
          
            <li>
              <h3>6. Diffie Hellman</h3>
              <ul>
                
                  <li class="pattern">
                    <a href="#introduction" >
                      <svg class="bookmark-icon" aria-hidden="true" viewBox="0 0 40 50" focusable="false">
                        <use xlink:href="#bookmark"></use>
                      </svg>
                      <span class="text">Introduction</span>
                    </a>
                  </li>
                
                  <li class="pattern">
                    <a href="#small-subgroup-confinement-attack" >
                      <svg class="bookmark-icon" aria-hidden="true" viewBox="0 0 40 50" focusable="false">
                        <use xlink:href="#bookmark"></use>
                      </svg>
                      <span class="text">Small Subgroup Confinement Attack</span>
                    </a>
                  </li>
                
              </ul>
            </li>
          
            <li>
              <h3>6. Elliptic Curve Cryptography</h3>
              <ul>
                
              </ul>
            </li>
          
        </ul>
      
    </nav>
    
    
      
        <div class="pattern-section">
          <h1 id="1.-where-to-begin" tabindex="-1">
            <svg class="bookmark-icon" aria-hidden="true" viewBox="0 0 40 50" focusable="false">
              <use xlink:href="#bookmark"></use>
            </svg>
            1. Where to begin
          </h1>
          
        </div>
      
        <div class="pattern-section">
          <h1 id="2.-basic-concepts" tabindex="-1">
            <svg class="bookmark-icon" aria-hidden="true" viewBox="0 0 40 50" focusable="false">
              <use xlink:href="#bookmark"></use>
            </svg>
            2. Basic Concepts
          </h1>
          
        </div>
      
        <div class="pattern-section">
          <h1 id="3.-classic-cryptography" tabindex="-1">
            <svg class="bookmark-icon" aria-hidden="true" viewBox="0 0 40 50" focusable="false">
              <use xlink:href="#bookmark"></use>
            </svg>
            3. Classic Cryptography
          </h1>
          
        </div>
      
        <div class="pattern-section">
          <h1 id="4.-stream-block-ciphers" tabindex="-1">
            <svg class="bookmark-icon" aria-hidden="true" viewBox="0 0 40 50" focusable="false">
              <use xlink:href="#bookmark"></use>
            </svg>
            4. Stream &amp; Block Ciphers
          </h1>
          
        </div>
      
        <div class="pattern-section">
          <h1 id="5.-rsa" tabindex="-1">
            <svg class="bookmark-icon" aria-hidden="true" viewBox="0 0 40 50" focusable="false">
              <use xlink:href="#bookmark"></use>
            </svg>
            5. RSA
          </h1>
          
        </div>
      
        <div class="pattern-section">
          <h1 id="6.-diffie-hellman" tabindex="-1">
            <svg class="bookmark-icon" aria-hidden="true" viewBox="0 0 40 50" focusable="false">
              <use xlink:href="#bookmark"></use>
            </svg>
            6. Diffie Hellman
          </h1>
          
        </div>
      
        <div class="pattern-section">
          <h1 id="6.-elliptic-curve-cryptography" tabindex="-1">
            <svg class="bookmark-icon" aria-hidden="true" viewBox="0 0 40 50" focusable="false">
              <use xlink:href="#bookmark"></use>
            </svg>
            6. Elliptic Curve Cryptography
          </h1>
          
        </div>
      
      
        
          <div class="pattern-section">
            <h1 id="hello-world" tabindex="-1">
              <svg class="bookmark-icon" aria-hidden="true" viewBox="0 0 40 50" focusable="false">
                <use xlink:href="#bookmark"></use>
              </svg>
              hello world
            </h1>
            
          </div>
        
          <div class="pattern-section">
            <h1 id="where-to-ghfghfcbegin" tabindex="-1">
              <svg class="bookmark-icon" aria-hidden="true" viewBox="0 0 40 50" focusable="false">
                <use xlink:href="#bookmark"></use>
              </svg>
              Where to ghfghfcbegin
            </h1>
            
          </div>
        
          <div class="pattern-section">
            <h1 id="hello-world-2" tabindex="-1">
              <svg class="bookmark-icon" aria-hidden="true" viewBox="0 0 40 50" focusable="false">
                <use xlink:href="#bookmark"></use>
              </svg>
              hello world 2
            </h1>
            
          </div>
        
      
        
          <div class="pattern-section">
            <h1 id="shift-cipher" tabindex="-1">
              <svg class="bookmark-icon" aria-hidden="true" viewBox="0 0 40 50" focusable="false">
                <use xlink:href="#bookmark"></use>
              </svg>
              Shift Cipher
            </h1>
            <p>A shift cipher, also known as a Caesar cipher, is a simple encryption technique that replaces each letter of a plaintext message with a letter a fixed number of positions down the alphabet. For example, if the shift value is 3, the letter &lsquo;A&rsquo; would be replaced by &lsquo;D&rsquo;, &lsquo;B&rsquo; would be replaced by &lsquo;E&rsquo;, and so on.</p>
<p>The shift value is also known as the key, and it determines the encryption and decryption process. The same key is used for both encryption and decryption. The encryption process is simply a shift to the right, and the decryption process is a shift to the left, using the same key value.</p>
<h4 id="the-formula-for-a-shift-cipher-encryption-is-as-follows">The formula for a shift cipher encryption is as follows:</h4>
<table>
<thead>
<tr>
<th>C ≡ (P + K) mod 26</th>
</tr>
</thead>
</table>
<ul>
<li>where:
<ul>
<li>C = the ciphertext (the encrypted message)</li>
<li>P = the plaintext (the original message)</li>
<li>K = the shift value (the key)</li>
<li>mod 26 = the modulo operation that brings the result of the addition within the range of 0 to 25, corresponding to the 26 letters of the alphabet.</li>
</ul>
</li>
</ul>
<h4 id="the-formula-for-a-shift-cipher-decryption-is-as-follows">The formula for a shift cipher decryption is as follows:</h4>
<table>
<thead>
<tr>
<th>P ≡ (C - K + 26) mod 26</th>
</tr>
</thead>
</table>
<ul>
<li>where:
<ul>
<li>P = the plaintext (the original message)</li>
<li>C = the ciphertext (the encrypted message)</li>
<li>K = the shift value (the key)</li>
<li>mod 26 = the modulo operation that brings the result of the subtraction within the range of 0 to 25, corresponding to the 26 letters of the alphabet.</li>
</ul>
</li>
</ul>
<h3 id="code">Code</h3>




<div class="code-annotated "><code>

def shift_cipher_encryption(plaintext, key):
    # create an empty list to store the ciphertext
    ciphertext = []
    for letter in plaintext:
        # only encrypt letters, not spaces or other characters
        if letter.isalpha():
            # shift the letter by the key value
            shifted_letter = chr((ord(letter) - ord(&#39;A&#39;) + key) % 26 + ord(&#39;A&#39;))
            ciphertext.append(shifted_letter)
        else:
            ciphertext.append(letter)
    return &#39;&#39;.join(ciphertext)

def shift_cipher_decryption(ciphertext, key):
    # create an empty list to store the plaintext
    plaintext = []
    for letter in ciphertext:
        # only decrypt letters, not spaces or other characters
        if letter.isalpha():
            # shift the letter by the negative of the key value
            shifted_letter = chr((ord(letter) - ord(&#39;A&#39;) - key + 26) % 26 + ord(&#39;A&#39;))
            plaintext.append(shifted_letter)
        else:
            plaintext.append(letter)
    return &#39;&#39;.join(plaintext)

# example usage
plaintext = &#34;HELLO WORLD&#34;
key = 3
ciphertext = shift_cipher_encryption(plaintext, key)
print(&#34;Ciphertext:&#34;, ciphertext)
decrypted_text = shift_cipher_decryption(ciphertext, key)
print(&#34;Decrypted text:&#34;, decrypted_text)
</code></div>


          </div>
        
          <div class="pattern-section">
            <h1 id="affine-cipher" tabindex="-1">
              <svg class="bookmark-icon" aria-hidden="true" viewBox="0 0 40 50" focusable="false">
                <use xlink:href="#bookmark"></use>
              </svg>
              Affine Cipher
            </h1>
            <p>An Affine cipher is a type of monoalphabetic substitution cipher, in which each letter in the plaintext is mapped to a unique fixed letter in the ciphertext. This mapping is based on a mathematical function, called the Affine function, that takes two inputs: the letter of the plaintext and two encryption keys, &ldquo;a&rdquo; and &ldquo;b&rdquo;.</p>
<h4 id="the-encryption-function-is-defined-as">The encryption function is defined as:</h4>
<table>
<thead>
<tr>
<th>C = (a*P + b) mod 26</th>
</tr>
</thead>
</table>
<ul>
<li>Where:
<ul>
<li>C = the ciphertext letter (the encrypted letter)</li>
<li>P = the plaintext letter (the original letter)</li>
<li>a, b = the encryption keys</li>
<li>mod 26 = the modulo operation that brings the result of the multiplication and addition within the range of 0 to 25, corresponding to the 26 letters of the alphabet.</li>
</ul>
</li>
</ul>
<p>To decrypt the ciphertext, the function uses the inverse of the encryption key &lsquo;a&rsquo; and the encryption key &lsquo;b&rsquo; to obtain the plaintext.</p>
<h4 id="the-decryption-function-is-defined-as">The decryption function is defined as:</h4>
<table>
<thead>
<tr>
<th>P = (a^-1 * (C - b)) mod 26</th>
</tr>
</thead>
</table>
<ul>
<li>Where:
<ul>
<li>P = the plaintext letter (the original letter)</li>
<li>C = the ciphertext letter (the encrypted letter)</li>
<li>a^-1 = the modular inverse of a (a^-1 * a = 1 mod 26)</li>
<li>b = the encryption key</li>
<li>mod 26 = the modulo operation that brings the result of the multiplication and subtraction within the range of 0 to 25, corresponding to the 26 letters of the alphabet.</li>
</ul>
</li>
</ul>
<p>The encryption and decryption keys &ldquo;a&rdquo; and &ldquo;b&rdquo; must be chosen such that &ldquo;a&rdquo; is relatively prime to 26 (i.e. it has no factors in common with 26) and that the modular inverse of &ldquo;a&rdquo; exists.</p>
<h3 id="code">Code</h3>




<div class="code-annotated "><code>
def affine_cipher_encryption(plaintext, a, b):
    # create an empty list to store the ciphertext
    ciphertext = []
    for letter in plaintext:
        # only encrypt letters, not spaces or other characters
        if letter.isalpha():
            # encrypt the letter using the Affine function
            encrypted_letter = chr(((a * (ord(letter) - ord(&#39;A&#39;))) + b) % 26 + ord(&#39;A&#39;))
            ciphertext.append(encrypted_letter)
        else:
            ciphertext.append(letter)
    return &#39;&#39;.join(ciphertext)

def affine_cipher_decryption(ciphertext, a, b):
    # calculate the modular inverse of a
    a_inv = inverse_mod(a, 26)
    # create an empty list to store the plaintext
    plaintext = []
    for letter in ciphertext:
        # only decrypt letters, not spaces or other characters
        if letter.isalpha():
            # decrypt the letter using the inverse Affine function
            decrypted_letter = chr((a_inv * ((ord(letter) - ord(&#39;A&#39;)) - b)) % 26 + ord(&#39;A&#39;))
            plaintext.append(decrypted_letter)
        else:
            plaintext.append(letter)
    return &#39;&#39;.join(plaintext)

# example usage
plaintext = &#34;HELLO WORLD&#34;
a = 5
b = 8
ciphertext = affine_cipher_encryption(plaintext, a, b)
print(&#34;Ciphertext:&#34;, ciphertext)
decrypted_text = affine_cipher_decryption(ciphertext, a, b)
print(&#34;Decrypted text:&#34;, decrypted_text)
</code></div>


          </div>
        
          <div class="pattern-section">
            <h1 id="atbash-cipher" tabindex="-1">
              <svg class="bookmark-icon" aria-hidden="true" viewBox="0 0 40 50" focusable="false">
                <use xlink:href="#bookmark"></use>
              </svg>
              Atbash Cipher
            </h1>
            <p>The Atbash Cipher is a simple form of monoalphabetic substitution cipher that uses the reverse of the alphabet as the key.</p>
<p>To encrypt a message, the first step is to reverse the alphabet. This can be done by writing down the alphabet, A-Z or a-z, in the usual order and then writing it down again in reverse order. Then, for each letter in the plaintext message, the corresponding letter in the reversed alphabet is used to encrypt it.</p>
<p>For example, to encrypt the letter “A”, the letter “Z” would be used. To encrypt the letter “B”, the letter “Y” would be used, and so on. The encryption process is done letter by letter in this way, and the resulting encrypted message is the ciphertext.</p>
<p>The decryption process is similar, it&rsquo;s just the reverse of the encryption process, the decryption key is the original alphabet.</p>
<p>Atbash Cipher is a very simple encryption method, it&rsquo;s easy to implement and understand, but it is easily broken by frequency analysis. It&rsquo;s not suitable for use in modern encryption scenarios.</p>
<h4 id="the-atbash-cipher-encryption-process-is-as-follows">The Atbash Cipher encryption process is as follows:</h4>
<ul>
<li>The first step is to create a reversed alphabet, for example, if we are using the English alphabet, it would be “ZYXWVUTSRQPONMLKJIHGFEDCBA”</li>
<li>The plaintext message is then converted letter by letter into the corresponding letter in the reversed alphabet.</li>
<li>The resulting letters form the ciphertext message.</li>
</ul>
<p>For example, if the plaintext message is “HELLO” and the reversed alphabet is “ZYXWVUTSRQPONMLKJIHGFEDCBA”, the ciphertext message would be “SVOOL”.</p>
<h4 id="the-atbash-cipher-decryption-process-is-as-follows">The Atbash Cipher decryption process is as follows:</h4>
<ul>
<li>The first step is to use the original alphabet.</li>
<li>The ciphertext message is then converted letter by letter into the corresponding letter in the original alphabet.</li>
<li>The resulting letters form the plaintext message.</li>
</ul>
<p>For example, if the ciphertext message is “SVOOL” and the original alphabet is “ABCDEFGHIJKLMNOPQRSTUVWXYZ”, the plaintext message would be “HELLO”.</p>
<p>It&rsquo;s important to note that this method can be applied to different alphabets and languages, it&rsquo;s just reversing the order of the letters in the alphabet.</p>
<h3 id="code">Code</h3>




<div class="code-annotated "><code>
def atbash_cipher_encryption(plaintext):
    alphabet = &#39;ABCDEFGHIJKLMNOPQRSTUVWXYZ&#39;
    reversed_alphabet = alphabet[::-1]
    ciphertext = []
    for letter in plaintext:
        if letter.isalpha():
            index = alphabet.index(letter.upper())
            ciphertext.append(reversed_alphabet[index])
        else:
            ciphertext.append(letter)
    return &#39;&#39;.join(ciphertext)

def atbash_cipher_decryption(ciphertext):
    alphabet = &#39;ABCDEFGHIJKLMNOPQRSTUVWXYZ&#39;
    reversed_alphabet = alphabet[::-1]
    plaintext = []
    for letter in ciphertext:
        if letter.isalpha():
            index = reversed_alphabet.index(letter.upper())
            plaintext.append(alphabet[index])
        else:
            plaintext.append(letter)
    return &#39;&#39;.join(plaintext)
</code></div>


          </div>
        
          <div class="pattern-section">
            <h1 id="playfair-cipher" tabindex="-1">
              <svg class="bookmark-icon" aria-hidden="true" viewBox="0 0 40 50" focusable="false">
                <use xlink:href="#bookmark"></use>
              </svg>
              Playfair Cipher
            </h1>
            <p>The Playfair Cipher is a polygraphic substitution cipher that encrypts pairs of letters instead of single letters. It uses a 5x5 grid of letters (called the key square or tableau) to encrypt pairs of letters.</p>
<p>To encrypt a message, the first step is to create the key square. This is done by choosing a keyword and writing it in a 5x5 grid, filling the remaining spaces with the remaining letters of the alphabet in alphabetical order, omitting the letter &lsquo;J&rsquo;.</p>
<p>For example, using the keyword &ldquo;PLAYFAIR&rdquo;, the grid would be:




<div class="code-annotated "><code>
P L A Y F
I R B C D
E G H K M
N O Q S T
U V W X Z
</code></div>

Then the plaintext message is divided into pairs of letters, if the message has an odd length, the last letter is padded with an &ldquo;X&rdquo; or any other letter.</p>
<h4 id="the-encryption-process-is-done-by-following-these-steps">The encryption process is done by following these steps:</h4>
<ul>
<li>If both letters of the pair are the same, an &ldquo;X&rdquo; or any other letter is added to the second letter to make them different.</li>
<li>If the letters are in the same row of the key square, the letters to the right of each one are used (wrapping around to the left side of the row if necessary)</li>
<li>If the letters are in the same column of the key square, the letters below each one are used (wrapping around to the top of the column if necessary)</li>
<li>If the letters are in different rows and columns, the letters at the intersections of the same row and column as each letter are used.
For example, using the key square above and the plaintext &ldquo;HELLO&rdquo;, the ciphertext would be &ldquo;CENNR&rdquo;.</li>
</ul>
<p>The Playfair Cipher decryption process is similar to the encryption process, but the opposite operations are applied.</p>
<p>To decrypt a message that was encrypted using the Playfair Cipher, the first step is to create the key square using the same keyword that was used to encrypt the message.</p>
<p>Then, the ciphertext message is divided into pairs of letters, just as it was done during the encryption process.</p>
<h4 id="the-decryption-process-is-done-by-following-these-steps">The decryption process is done by following these steps:</h4>
<ul>
<li>If the letters are in the same row of the key square, the letters to the left of each one are used (wrapping around to the right side of the row if necessary)</li>
<li>If the letters are in the same column of the key square, the letters above each one are used (wrapping around to the bottom of the column if necessary)</li>
<li>If the letters are in different rows and columns, the letters at the intersections of the same row and column as each letter are used.
For example, using the key square created with the keyword &ldquo;PLAYFAIR&rdquo; and the ciphertext &ldquo;CENNR&rdquo;, the plaintext would be &ldquo;HELLO&rdquo;.</li>
</ul>
<p>It&rsquo;s important to note that this decryption process assumes that the key square was created using the same keyword as the one used to encrypt the message and that the plaintext message was padded with &ldquo;X&rdquo; or any other letter if necessary.</p>
<h3 id="code">Code</h3>




<div class="code-annotated "><code>
import re


def textCleaning(text):
    text = text.upper()
    text = re.sub(r&#39;\s*\d+\s*&#39;, &#39;&#39;, text)
    text = re.sub(r&#39;[^\w\s]&#39;, &#39;&#39;, text)
    text = text.replace(&#39; &#39;, &#39;&#39;)
    return text


def postProcess(text):
    text = [text[i:i+5] for i in range(0, len(text), 5)]
    text = &#39; &#39;.join(text)

    return text


def matrix(x, y, initial):
    return [[initial for i in range(x)] for j in range(y)]


def locateIndex(c, playFairMatrix):  # get location of each character
    loc = list()
    if c == &#39;J&#39;:
        c = &#39;I&#39;
    for i, j in enumerate(playFairMatrix):
        for k, l in enumerate(j):
            if c == l:
                loc.append(i)
                loc.append(k)
                return loc


def encrypt(text, playFairMatrix):
    text = textCleaning(text)
    cipher = &#39;&#39;
    i = 0
    for s in range(0, len(text)+1, 2):
        if s &lt; len(text)-1:
            if text[s] == text[s+1]:
                text = text[:s+1]+&#39;X&#39;+text[s+1:]

    if len(text) % 2 != 0:
        text = text[:]+&#39;X&#39;

    # print(&#34;CIPHER TEXT:&#34;, end=&#39;&#39;)

    while i &lt; len(text):
        loc = list()
        loc = locateIndex(text[i], playFairMatrix)
        loc1 = list()
        loc1 = locateIndex(text[i+1], playFairMatrix)
        if loc[1] == loc1[1]:
            cipher += playFairMatrix[(loc[0]+1)%5][loc[1]] + playFairMatrix[(loc1[0]+1)%5][loc1[1]]
            # print(&#34;{}{}&#34;.format(playFairMatrix[(loc[0]+1)%5][loc[1]],playFairMatrix[(loc1[0]+1)%5][loc1[1]]),end=&#39; &#39;)
        elif loc[0] == loc1[0]:
            cipher += playFairMatrix[loc[0]][(loc[1]+1) % 5] + playFairMatrix[loc1[0]][(loc1[1]+1) % 5]
            # print(&#34;{}{}&#34;.format(playFairMatrix[loc[0]][(loc[1]+1)%5],playFairMatrix[loc1[0]][(loc1[1]+1)%5]),end=&#39; &#39;)
        else:
            cipher += playFairMatrix[loc[0]][loc1[1]] + playFairMatrix[loc1[0]][loc[1]]
            # print(&#34;{}{}&#34;.format(playFairMatrix[loc[0]][loc1[1]],playFairMatrix[loc1[0]][loc[1]]),end=&#39; &#39;)
        i = i+2

    cipher = postProcess(cipher)

    return cipher


def decrypt(cipher, playFairMatrix):  # decryption
    cipher = textCleaning(cipher)
    plainText = &#39;&#39;
    # print(&#34;PLAIN TEXT:&#34;, end=&#39; &#39;)
    i = 0
    while i &lt; len(cipher):
        loc = list()
        loc = locateIndex(cipher[i], playFairMatrix)
        loc1 = list()
        loc1 = locateIndex(cipher[i+1], playFairMatrix)
        if loc[1] == loc1[1]:
            plainText += playFairMatrix[(loc[0]-1) % 5][loc[1]] + \
                playFairMatrix[(loc1[0]-1) % 5][loc1[1]]
            # print(&#34;{}{}&#34;.format(playFairMatrix[(loc[0]-1)%5][loc[1]],playFairMatrix[(loc1[0]-1)%5][loc1[1]]),end=&#39; &#39;)
        elif loc[0] == loc1[0]:
            plainText += playFairMatrix[loc[0]][(loc[1]-1) %
                                                5] + playFairMatrix[loc1[0]][(loc1[1]-1) % 5]
            # print(&#34;{}{}&#34;.format(playFairMatrix[loc[0]][(loc[1]-1)%5],playFairMatrix[loc1[0]][(loc1[1]-1)%5]),end=&#39; &#39;)
        else:
            plainText += playFairMatrix[loc[0]][loc1[1]
                                                ] + playFairMatrix[loc1[0]][loc[1]]
            # print(&#34;{}{}&#34;.format(playFairMatrix[loc[0]][loc1[1]],playFairMatrix[loc1[0]][loc[1]]),end=&#39; &#39;)
        i = i+2

    plainText = postProcess(plainText)

    return plainText


def generatePlayfairSquare(key):
    key = key.upper()
    result = list()

    for c in key:  # storing key
        if c not in result:
            if c == &#39;J&#39;:  # replacing j with i
                result.append(&#39;I&#39;)
            else:
                result.append(c)

    flag = 0

    for i in range(65, 91):  # storing other character
        if chr(i) not in result:
            if i == 73 and chr(74) not in result:
                result.append(&#34;I&#34;)
                flag = 1
            elif flag == 0 and i == 73 or i == 74:
                pass
            else:
                result.append(chr(i))
    k = 0
    my_matrix = matrix(5, 5, 0)  # initialize matrix
    for i in range(0, 5):  # making matrix
        for j in range(0, 5):
            my_matrix[i][j] = result[k]
            k += 1

    return my_matrix

def main():
    while(1):
        choice=int(input(&#34;\n 1.Encryption \n 2.Decryption: \n 3.EXIT \n&#34;))
        key=input(&#34;Enter key : &#34;)
        key = textCleaning(key)

        PS = generatePlayfairSquare(key)
        if choice==1:
            plainText = input(&#34;Enter Plaintext : &#34;)
            plainText = textCleaning(plainText)
            print(encrypt(plainText, PS))
        elif choice==2:
            cipher = input(&#39;Enter cipher : &#39;)
            cipher = textCleaning(cipher)
            print(decrypt(cipher,PS))
        elif choice==3:
            exit()
        else:
            print(&#34;Choose correct choice&#34;)
    return 0

if __name__ == &#39;__main__&#39;:
    main()
</code></div>


          </div>
        
      
        
          <div class="pattern-section">
            <h1 id="introduction" tabindex="-1">
              <svg class="bookmark-icon" aria-hidden="true" viewBox="0 0 40 50" focusable="false">
                <use xlink:href="#bookmark"></use>
              </svg>
              Introduction
            </h1>
            <p>Stream ciphers and block ciphers are two common types of symmetric encryption algorithms.</p>
<p>A stream cipher encrypts plaintext one bit or byte at a time, while a block cipher encrypts plaintext in fixed-size blocks, typically 128 or 256 bits at a time.</p>
<p>Stream ciphers are used in real-time applications where data is transmitted continuously, such as in wireless communications or streaming audio and video. They are efficient in terms of computation and memory usage and can encrypt data quickly and securely. Examples of stream ciphers include A5/1 and RC4.</p>
<p>Block ciphers, on the other hand, are used to encrypt large amounts of data, such as files or entire disk drives. They are more secure than stream ciphers but require more computation and memory resources. Examples of block ciphers include AES and DES.</p>
<p>In both cases, the encryption process is performed using a secret key, and the decryption process is performed using the same key. This ensures that only authorized parties can access the encrypted data.</p>
<p>It&rsquo;s worth noting that both block ciphers and stream ciphers can be used in various modes of operation, like Electronic Codebook (ECB), Cipher Block Chaining (CBC), Cipher Feedback (CFB), Output Feedback (OFB) and Counter (CTR) mode, each one of them has its own security and practical properties.</p>

          </div>
        
          <div class="pattern-section">
            <h1 id="single-byte-xor" tabindex="-1">
              <svg class="bookmark-icon" aria-hidden="true" viewBox="0 0 40 50" focusable="false">
                <use xlink:href="#bookmark"></use>
              </svg>
              Single Byte XOR
            </h1>
            <p>Single-Byte XOR, also known as Single Character XOR, is a simple form of XOR encryption that encrypts each byte of the plaintext message using a single byte key. The encryption process is done by applying the XOR operation between the plaintext byte and the key byte.</p>
<p>The decryption process is the same as the encryption process, it&rsquo;s just the reverse of the encryption process, the decryption key is the same key used for encryption.</p>
<p>Here&rsquo;s an example of how you might implement Single-Byte XOR encryption and decryption in Sage:</p>




<div class="code-annotated "><code>
def single_byte_xor_encryption(plaintext, key):
    ciphertext = &#34;&#34;
    for i in range(len(plaintext)):
        ciphertext += chr(ord(plaintext[i]) ^ ord(key[i % len(key)]))
    return ciphertext

def single_byte_xor_decryption(ciphertext, key):
    plaintext = &#34;&#34;
    for i in range(len(ciphertext)):
        plaintext += chr(ord(ciphertext[i]) ^ ord(key[i % len(key)]))
    return plaintext
</code></div>

<p>It&rsquo;s important to note that Single-Byte XOR is not considered a secure encryption method and should not be used in real-world scenarios, it can be easily broken by frequency analysis, and other methods.</p>

          </div>
        
          <div class="pattern-section">
            <h1 id="repeated-key-xor" tabindex="-1">
              <svg class="bookmark-icon" aria-hidden="true" viewBox="0 0 40 50" focusable="false">
                <use xlink:href="#bookmark"></use>
              </svg>
              Repeated Key XOR
            </h1>
            <p>Repeated Key XOR is a type of encryption that uses the XOR operation to encrypt plaintext by repeatedly applying a secret key to it. In this method, the key is repeated as many times as necessary to match the length of the plaintext. The encryption process works by taking each plaintext byte and the corresponding byte of the key, and applying the XOR operation between them. The result is the ciphertext.</p>
<p>Decryption is the inverse process of encryption, it takes the ciphertext and the same key used for encryption and applies the XOR operation between them, which results in the original plaintext.</p>




<div class="code-annotated "><code>
def repeated_key_xor_encryption(plaintext:str, key:str):
    ciphertext = &#34;&#34;
    for i in range(len(plaintext)):
        ciphertext += chr(ord(plaintext[i]) ^ ord(key[i % len(key)]))
    return ciphertext

def repeated_key_xor_decryption(ciphertext:str, key:str):
    plaintext = &#34;&#34;
    for i in range(len(ciphertext)):
        plaintext += chr(ord(ciphertext[i]) ^ ord(key[i % len(key)]))
    return plaintext
</code></div>


          </div>
        
          <div class="pattern-section">
            <h1 id="transposition-ciphers" tabindex="-1">
              <svg class="bookmark-icon" aria-hidden="true" viewBox="0 0 40 50" focusable="false">
                <use xlink:href="#bookmark"></use>
              </svg>
              Transposition ciphers
            </h1>
            <p>Transposition ciphers are a type of encryption technique that rearrange the positions of the letters in the plaintext to produce the ciphertext. The plaintext is rearranged according to a specific rule or method, such as a regular pattern or a secret key. The process of encryption is reversible, meaning that the original plaintext can be obtained by rearranging the ciphertext using the same rule or method.</p>
<p>There are several types of transposition ciphers, such as:</p>
<p>Columnar Transposition: This cipher rearranges the letters of the plaintext by writing them in a grid and then reading the columns in a specific order.</p>
<p>Rail Fence: This cipher rearranges the letters of the plaintext by writing them in a zigzag pattern along a set number of &ldquo;rails&rdquo; and then reading the letters off in a specific order.</p>
<p>Route Cipher: This cipher rearranges the letters of the plaintext by writing them in a grid and then reading the letters off in a specific route, such as a snake-like pattern.</p>
<p>Book Cipher: This cipher rearranges the letters of the plaintext by assigning each letter a number and then using a book or other prearranged text to look up the corresponding ciphertext letter.</p>
<p>It&rsquo;s important to note that transposition ciphers are not considered very secure encryption method and can be easily broken by frequency analysis and other methods. They are mainly used to provide an additional layer of security on top of another encryption method.</p>




<div class="code-annotated "><code>

def columnar_transposition_encryption(plaintext:str, key:str):
    ciphertext = &#34;&#34;
    grid = []
    for i in range(len(plaintext)):
        grid.append(plaintext[i])
    for i in range(len(key)):
        ciphertext += grid[i::len(key)]
    return ciphertext

def columnar_transposition_decryption(ciphertext:str, key:str):
    plaintext = &#34;&#34;
    grid = []
    for i in range(len(ciphertext)):
        grid.append(ciphertext[i])
    for i in range(len(key)):
        plaintext += grid[i::len(key)]
    return plaintext

</code></div>


          </div>
        
          <div class="pattern-section">
            <h1 id="modes-of-block-cipher" tabindex="-1">
              <svg class="bookmark-icon" aria-hidden="true" viewBox="0 0 40 50" focusable="false">
                <use xlink:href="#bookmark"></use>
              </svg>
              Modes of block cipher
            </h1>
            <p>A block cipher is a type of symmetric key encryption that encrypts data in fixed-size blocks (typically 64 or 128 bits). There are several different modes of encryption that can be used with a block cipher to encrypt data of any size:</p>
<p>Electronic Code Book (ECB) mode: This is the simplest and most basic mode of encryption. Each block of plaintext is independently encrypted with the same key, resulting in a block of ciphertext of the same size. However, ECB mode is vulnerable to certain types of attacks, such as a known-plaintext attack, where an attacker can determine the key by analyzing a large number of ciphertext blocks.</p>
<p>Cipher Block Chaining (CBC) mode: In this mode, a unique initialization vector (IV) is used to encrypt the first block of plaintext. For subsequent blocks of plaintext, the previous block of ciphertext is XORed with the current block of plaintext before encryption. This creates a chain of ciphertext blocks that are dependent on each other, making it more secure than ECB mode.</p>
<p>Cipher Feedback (CFB) mode: This mode is similar to CBC mode, but instead of using the previous block of ciphertext, a block of ciphertext is used to encrypt the next block of plaintext. This creates a similar chain of ciphertext blocks that are dependent on each other, making it more secure than ECB mode.</p>
<p>Output Feedback (OFB) mode: In this mode, a block of ciphertext is used to encrypt the next block of plaintext, but unlike CFB mode, the ciphertext is not fed back into the encryption process. This creates a similar chain of ciphertext blocks that are dependent on each other, making it more secure than ECB mode.</p>
<p>Counter (CTR) mode: This mode uses a counter to encrypt the plaintext. The counter is combined with the key to encrypt each block of plaintext. This mode is similar to OFB mode but the encryption process is slightly more complex. It&rsquo;s considered to be more secure than ECB and other feedback modes.</p>

          </div>
        
      
        
          <div class="pattern-section">
            <h1 id="introduction" tabindex="-1">
              <svg class="bookmark-icon" aria-hidden="true" viewBox="0 0 40 50" focusable="false">
                <use xlink:href="#bookmark"></use>
              </svg>
              Introduction
            </h1>
            <p>RSA is a widely-used public-key encryption system that is based on the mathematical properties of large prime numbers. It was one of the first practical public-key cryptosystems and is widely used for secure data transmission.</p>
<p>The RSA encryption process consists of two parts: key generation and encryption/decryption.</p>
<p>Key Generation:</p>
<ul>
<li>Select two large prime numbers, p and q.</li>
<li>Compute n = p*q. n is used as the modulus for both the public and private keys.</li>
<li>Compute the totient of n, φ(n) = (p-1)*(q-1).</li>
<li>Select a public exponent e, such that 1 &lt; e &lt; φ(n) and e is coprime to φ(n).</li>
<li>Compute the private exponent d, such that d*e = 1 mod φ(n).</li>
</ul>
<p>Encryption/Decryption:</p>
<ul>
<li>For encryption, the plaintext message is represented as a number m. The ciphertext c is computed as c = m^e mod n.</li>
<li>For decryption, the ciphertext c is input and the plaintext message m is computed as m = c^d mod n.</li>
</ul>




<div class="code-annotated "><code>
from math import gcd
from random import randrange

def generate_keypair(p, q):
    if not (is_prime(p) and is_prime(q)):
        raise ValueError(&#39;Both numbers must be prime.&#39;)
    elif p == q:
        raise ValueError(&#39;p and q cannot be equal&#39;)
    n = p * q
    phi = (p-1) * (q-1)
    e = randrange(1, phi)
    g = gcd(e, phi)
    while g != 1:
        e = randrange(1, phi)
        g = gcd(e, phi)
    d = multiplicative_inverse(e, phi)
    return ((e, n), (d, n))

def encrypt(pk, plaintext):
    key, n = pk
    cipher = [(ord(char) ** key) % n for char in plaintext]
    return cipher

def decrypt(pk, ciphertext):
    key, n = pk
    plain = [chr((char ** key) % n) for char in ciphertext]
    return &#39;&#39;.join(plain)
</code></div>


          </div>
        
          <div class="pattern-section">
            <h1 id="common-modulus-attack" tabindex="-1">
              <svg class="bookmark-icon" aria-hidden="true" viewBox="0 0 40 50" focusable="false">
                <use xlink:href="#bookmark"></use>
              </svg>
              Common Modulus Attack
            </h1>
            <p>A common modulus attack on RSA is a type of cryptographic attack that takes advantage of the properties of RSA encryption when the same modulus is used for multiple encryptions.</p>
<p>In RSA, encryption is performed by raising the plaintext message to the power of the public exponent (e) and taking the remainder when divided by the modulus (n). Similarly, decryption is performed by raising the ciphertext to the power of the private exponent (d) and taking the remainder when divided by the modulus (n).</p>
<p>In a common modulus attack, an attacker intercepts multiple ciphertexts that have been encrypted using the same modulus (n), but with different public exponents (e1, e2, &hellip;, en). The attacker can then use mathematical techniques to recover the plaintext message, even if the private exponent (d) is not known.</p>
<p>One way to perform a common modulus attack is to use the Chinese Remainder Theorem (CRT) to combine the equations of multiple ciphertexts, allowing the attacker to solve for the plaintext. Another way is to use the Euclidean algorithm to calculate the greatest common divisor of the multiple public exponents (e1, e2, &hellip;, en) and the modulus (n) to obtain the private exponent (d) and then use it to decrypt the ciphertexts.</p>




<div class="code-annotated "><code>
from sage.all import xgcd


def attack(n, e1, c1, e2, c2):
    &#34;&#34;&#34;
    Recovers the plaintext from two ciphertexts, encrypted using the same modulus and different public exponents.
    :param n: the common modulus
    :param e1: the first public exponent
    :param c1: the ciphertext of the first encryption
    :param e2: the second public exponent
    :param c2: the ciphertext of the second encryption
    :return: the plaintext
    &#34;&#34;&#34;
    _, u, v = xgcd(e1, e2)
    p1 = pow(c1, u, n) if u &gt; 0 else pow(pow(c1, -1, n), -u, n)
    p2 = pow(c2, v, n) if v &gt; 0 else pow(pow(c2, -1, n), -v, n)
    return int(p1 * p2) % n
</code></div>


          </div>
        
          <div class="pattern-section">
            <h1 id="hastads-broadcast-attack" tabindex="-1">
              <svg class="bookmark-icon" aria-hidden="true" viewBox="0 0 40 50" focusable="false">
                <use xlink:href="#bookmark"></use>
              </svg>
              Hastad&#39;s Broadcast Attack
            </h1>
            <h2 id="hastads-broadcast-attack-on-unpadded-messages">Hastad&rsquo;s Broadcast Attack on unpadded messages</h2>
<p>Consider a scenario where Alice transmits an unpadded message (M) to k people labeled P1,P2,&hellip;,Pk. Each recipient has an identical small public key exponent (e) and distinct moduli (N) for every ith individual (Ni,e). Here the vulnerability arises when the number of recipients k is greater than or equal to e (k&gt;=e). Once this happens the security of message M is compromised and it can be recovered through application of Chinese Remainder Theorem.</p>
<p>To illustrate this attack, let&rsquo;s consider a example where Alice sends a message M to 3 three different people using the same public key exponent e = 3. Let the ciphertext received by ith receiver be Ci where Ci = M3 mod Ni. We have to assume that gcd(Ni, Nj) == 1 where i != j.</p>
<p>Now we can write :
$$
M^3 = C_1 \mod N_1 \
M^3 = C_2 \mod N_2 \
M^3 = C_3 \mod N_3 \
$$
Thus we can get the following by solving using Chinese Remainder Theorem:
$$
M^3 = \sum_{i=1}^{3} C_i b_i b'_i \pmod{N}
$$
where <em>bi = N/Ni, bi' = bi-1 mod Ni and N = N1 N2 N3</em>. Since we know that M &lt; Ni (If our message M is larger than the modulus N, then we won&rsquo;t get the exact message when we decrypt the ciphertext, we will get an equivalent message instead, which is not favourable).
Therefore we can write M &lt; N1N2N3. We can easily calculate M now by directly taking the cube root of M3 to get M.</p>
<p>Hastad also showed that applying linear padding to the message M prior to encryption does not protect from this attack.</p>




<div class="code-annotated "><code>
import os
import sys
from math import gcd

path = os.path.dirname(os.path.dirname(os.path.dirname(os.path.realpath(os.path.abspath(__file__)))))
if sys.path[1] != path:
    sys.path.insert(1, path)

from attacks.rsa import low_exponent
from shared.crt import fast_crt


def attack(N, e, c):
    &#34;&#34;&#34;
    Recovers the plaintext from e ciphertexts, encrypted using different moduli and the same public exponent.
    :param N: the moduli
    :param e: the public exponent
    :param c: the ciphertexts
    :return: the plaintext
    &#34;&#34;&#34;
    assert e == len(N) == len(c), &#34;The amount of ciphertexts should be equal to e.&#34;

    for i in range(len(N)):
        for j in range(len(N)):
            if i != j and gcd(N[i], N[j]) != 1:
                raise ValueError(f&#34;Modulus {i} and {j} share factors, Hastad&#39;s attack is impossible.&#34;)

    c, _ = fast_crt(c, N)
    return low_exponent.attack(e, c)
</code></div>


          </div>
        
          <div class="pattern-section">
            <h1 id="wiener-attack" tabindex="-1">
              <svg class="bookmark-icon" aria-hidden="true" viewBox="0 0 40 50" focusable="false">
                <use xlink:href="#bookmark"></use>
              </svg>
              Wiener Attack
            </h1>
            <p>The Wiener attack is a method for attacking RSA encryption when the private exponent (d) is small relative to the modulus (n). This method is named after mathematician David Wiener, who first described it in a 1990 paper.</p>
<p>The Wiener attack takes advantage of the fact that the private exponent (d) is typically much smaller than the modulus (n) in RSA encryption. If the private exponent (d) is small enough, it is possible to calculate the private key using the relationship between the private exponent (d) and the public exponent (e) in RSA. The relationship is d*e = 1 (mod φ(n)), where φ(n) is the Euler&rsquo;s totient function of n.</p>
<p>The Wiener attack consists of finding the continued fraction representation of e/n and then using this information to obtain the private key. The process of finding the continued fraction representation of e/n is done by applying the Euclidean algorithm to e and n. Once the continued fraction representation is found, the attack is carried out by computing the convergents of the continued fraction and checking them against the private exponent (d).</p>
<p>The Wiener attack is only possible when the private exponent (d) is small enough, which typically occurs when the public exponent (e) is chosen to be a small number, such as 3 or 65537. In practice, it&rsquo;s recommended to use large public exponents, like 65537, which make Wiener attack infeasible.</p>
<p>It&rsquo;s important to note that the Wiener attack has been largely obsoleted by more powerful methods for attacking RSA encryption, such as the Franklin-Reiter related message attack and the Boneh-Durfee attack, which can be used to recover the private key even when the private exponent is not small relative to the modulus.</p>




<div class="code-annotated "><code>  
from sage.all import ZZ
from sage.all import continued_fraction

def attack(N, e):
    &#34;&#34;&#34;
    Recovers the prime factors of a modulus and the private exponent if the private exponent is too small.
    :param N: the modulus
    :param e: the public exponent
    :return: a tuple containing the prime factors and the private exponent, or None if the private exponent was not found
    &#34;&#34;&#34;
    convergents = continued_fraction(ZZ(e) / ZZ(N)).convergents()
    for c in convergents:
        k = c.numerator()
        d = c.denominator()
        if pow(pow(2, e, N), d, N) != 2:
            continue

        phi = (e * d - 1) // k
        factors = known_phi.factorize(N, phi)
        if factors:
            return *factors, int(d)

</code></div>


          </div>
        
          <div class="pattern-section">
            <h1 id="factorisation" tabindex="-1">
              <svg class="bookmark-icon" aria-hidden="true" viewBox="0 0 40 50" focusable="false">
                <use xlink:href="#bookmark"></use>
              </svg>
              Factorisation
            </h1>
            <h3 id="fermats-factorisation-method">Fermat&rsquo;s Factorisation Method</h3>
<p>Fermat&rsquo;s factorization is an algorithm for factoring integers that is based on Fermat&rsquo;s Little Theorem. The theorem states that if p is a prime number, then for any integer a, the number a^p - a is an integer multiple of p. The algorithm for factoring an integer N is to find two integers a and b such that a^2 - Nb^2 = 1. If such integers are found, then N is the product of the two factors a+b and a-b. The algorithm is based on the idea that if N is composite, then it is possible to find such integers a and b by trying different values of a and using the equation to calculate b. However, this method is not always efficient and has been largely superseded by more efficient algorithms such as the General Number Field Sieve.</p>




<div class="code-annotated "><code>
from math import isqrt

def is_square(x):
    &#34;&#34;&#34;
    Returns the square root of x if x is a perfect square, or None otherwise.
    :param x: x
    :return: the square root of x or None
    &#34;&#34;&#34;
    y = isqrt(x)
    return y if y ** 2 == x else None

def factorize(N):
    &#34;&#34;&#34;
    Recovers the prime factors from a modulus using Fermat&#39;s factorization method.
    :param N: the modulus
    :return: a tuple containing the prime factors, or None if the factors were not found
    &#34;&#34;&#34;
    a = isqrt(N)
    b = a * a - N
    while b &lt; 0 or not is_square(b):
        a += 1
        b = a * a - N

    p = a - isqrt(b)
    q = N // p
    if p * q == N:
        return p, q

</code></div>


          </div>
        
          <div class="pattern-section">
            <h1 id="coppersmiths-method" tabindex="-1">
              <svg class="bookmark-icon" aria-hidden="true" viewBox="0 0 40 50" focusable="false">
                <use xlink:href="#bookmark"></use>
              </svg>
              Coppersmith&#39;s Method
            </h1>
            <p>Coppersmith&rsquo;s attack is a technique used in cryptography to factorize the private key of a public key encryption system. It is applied specifically to RSA encryption, which is one of the most widely used public key encryption systems.</p>
<p>In RSA encryption, the private key is generated by multiplying two prime numbers. Coppersmith&rsquo;s attack exploits the low-order bits of the private key to find the prime factors. The technique is based on the observation that the modular reduction operation used in RSA encryption does not affect the lower order bits of the private key. This makes it possible to find the prime factors by solving a system of linear equations.</p>
<p>The Coppersmith&rsquo;s attack is efficient when the size of the private key is small, and the number of bits required to represent the prime factors is small compared to the total size of the private key.</p>




<div class="code-annotated "><code>
import logging
import os
import sys
from math import *
from sage.all import *

def factorize_p(N, partial_p, beta=0.5, epsilon=0.125, m=None, t=None):
    &#34;&#34;&#34;
    Recover the prime factors from a modulus using Coppersmith&#39;s method and bits of one prime factor p are known.
    More information: May A., &#34;New RSA Vulnerabilities Using Lattice Reduction Methods&#34; (Section 3.2)
    More information: Herrmann M., May A., &#34;Solving Linear Equations Modulo Divisors: On Factoring Given Any Bits&#34; (Section 3 and 4)
    :param N: the modulus
    :param partial_p: the partial prime factor p (PartialInteger)
    :param beta: the parameter beta (default: 0.5)
    :param epsilon: the parameter epsilon (default: 0.125)
    :param m: the number of normal shifts to use (default: automatically computed using beta and epsilon)
    :param t: the number of additional shifts to use (default: automatically computed using beta and epsilon)
    :return: a tuple containing the prime factors, or None if the factors could not be found
    &#34;&#34;&#34;
    n = partial_p.unknowns
    assert n &gt; 0
    if n == 1:
        m = ceil(max(beta ** 2 / epsilon, 7 * beta)) if m is None else m
        t = int((1 / beta - 1) * m) if t is None else t
        small_roots = howgrave_graham.modular_univariate
    elif n == 2:
        m = ceil((3 * beta * (1 + sqrt(1 - beta))) / epsilon) if m is None else m
        t = int((1 - sqrt(1 - beta)) * m) if t is None else t
        small_roots = herrmann_may_multivariate.modular_multivariate
    else:
        m = ceil((n * (1 / pi * (1 - beta) ** (-0.278465) - beta * log(1 - beta))) / epsilon) if m is None else m
        t = int((1 - (1 - beta) ** (1 / n)) * m) if t is None else t
        small_roots = herrmann_may_multivariate.modular_multivariate

    x = Zmod(N)[tuple(f&#34;x{i}&#34; for i in range(n))].gens()
    f = partial_p.sub(x)
    X = partial_p.get_unknown_bounds()
    logging.info(f&#34;Trying m = {m}, t = {t}...&#34;)
    for roots in small_roots(f, N, m, t, X):
        p = partial_p.sub(roots)
        if p != 0 and N % p == 0:
            return p, N // p

    return None
</code></div>


          </div>
        
      
        
          <div class="pattern-section">
            <h1 id="introduction" tabindex="-1">
              <svg class="bookmark-icon" aria-hidden="true" viewBox="0 0 40 50" focusable="false">
                <use xlink:href="#bookmark"></use>
              </svg>
              Introduction
            </h1>
            <p>The Diffie-Hellman key exchange is the method of safely developing and exchanging keys over an insecure channel. It allows two parties to establish a shared secret key over an unsecured communication channel. Unlike RSA, which is primarily used for encryption, Diffie-Hellman is focused on secure key exchange.</p>
<p>Working:</p>
<ul>
<li>Let&rsquo;s say, two parties, Alice and Bob agree on two large prime numbers, p and g, and a public key exchange algorithm.</li>
<li>Alice chooses a secret integer, a, and computes A = g^a mod p. She sends A to Bob.</li>
<li>Bob chooses a secret integer, b, and computes B = g^b mod p. He sends B to Alice.</li>
<li>Alice computes s = B^a mod p. Bob computes s = A^b mod p.</li>
<li>Alice and Bob now both have the shared secret key s, which they can use to establish a secure communication channel.</li>
</ul>
<p>The security of the Diffie-Hellman key exchange relies on the fact that it is computationally infeasible for an attacker to determine the shared secret keys from the public values of p, g, A, and B. This allows Alice and Bob to exchange the key securely, even over an insecure channel.</p>
<p>The most interesting part of the Diffie-Hellman key exchange is that both parties end up with the same result, without ever needing to send the entirety of the common secret across the communication channel.</p>




<div class="code-annotated "><code>

import random

p = 29              # Shared prime number and base (these should be agreed upon in advance)
g = 7

alice_private = random.randint(1, p - 1)            # Alice&#39;s private key

bob_private = random.randint(1, p - 1)            # Bob&#39;s private key

alice_public = (g ** alice_private) % p                 # Compute public keys
bob_public = (g ** bob_private) % p

# Alice and Bob exchanges public keys with each other

alice_shared_secret = (bob_public ** alice_private) % p           # Alice and Bob now compute the shared secret
bob_shared_secret = (alice_public ** bob_private) % p

# The shared secrets should be the same
print(&#34;Shared Secret (Alice):&#34;, alice_shared_secret)
print(&#34;Shared Secret (Bob):&#34;, bob_shared_secret)
</code></div>


          </div>
        
          <div class="pattern-section">
            <h1 id="small-subgroup-confinement-attack" tabindex="-1">
              <svg class="bookmark-icon" aria-hidden="true" viewBox="0 0 40 50" focusable="false">
                <use xlink:href="#bookmark"></use>
              </svg>
              Small Subgroup Confinement Attack
            </h1>
            
          </div>
        
      
        
      
    
  </main>

          <footer role="contentinfo">
            <div>
              <label for="themer">
                dark theme: <input type="checkbox" id="themer" class="vh">
                <span aria-hidden="true"></span>
              </label>
            </div>
            
          </footer>
        </div>
      </div>
    </div>
    <script src="https://victim1307.github.io/cryptolearn/js/prism.js"></script>
    <script src="https://victim1307.github.io/cryptolearn/js/dom-scripts.js"></script>
    
  </body>
</html>
